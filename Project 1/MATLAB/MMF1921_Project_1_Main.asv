%% MMF1921 (Summer 2025) - Project 1
% 
% The purpose of this program is to implement the following factor models
% a) Multi-factor OLS regression
% b) Fama-French 3-factor model
% c) LASSO
% d) Best Subset Selection
% 
% and to use these factor models to estimate the asset expected returns and 
% covariance matrix. These parameters will then be used to test the 
% out-of-sample performance using MVO to construct optimal portfolios.
% 
% Use can use this template to write your program.
%
% Student Name:
% Student ID:

clc
clear all
format short

% Program Start
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 1. Read input files
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Load the stock weekly prices
adjClose = readtable('MMF1921_AssetPrices.csv');
adjClose.Properties.RowNames = cellstr(datetime(adjClose.Date));
adjClose.Properties.RowNames = cellstr(datetime(adjClose.Properties.RowNames));
adjClose.Date = [];

% Load the factors weekly returns
factorRet = readtable('MMF1921_FactorReturns.csv');
factorRet.Properties.RowNames = cellstr(datetime(factorRet.Date));
factorRet.Properties.RowNames = cellstr(datetime(factorRet.Properties.RowNames));
factorRet.Date = [];

riskFree = factorRet(:,9);
factorRet = factorRet(:,1:8);

% Identify the tickers and the dates 
tickers = adjClose.Properties.VariableNames';
dates   = datetime(factorRet.Properties.RowNames);

% Calculate the stocks' weekly EXCESS returns
prices  = table2array(adjClose);
returns = ( prices(2:end,:) - prices(1:end-1,:) ) ./ prices(1:end-1,:);
returns = returns - ( diag( table2array(riskFree) ) * ones( size(returns) ) );
returns = array2table(returns);
returns.Properties.VariableNames = tickers;
returns.Properties.RowNames = cellstr(datetime(factorRet.Properties.RowNames));

% Align the price table to the asset and factor returns tables by
% discarding the first observation.
adjClose = adjClose(2:end,:);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2. Define your initial parameters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Initial budget to invest ($100,000)
initialVal = 100000;

% Start of in-sample calibration period 
calStart = datetime('2008-01-01');
calEnd   = calStart + calyears(4) - days(1);

% Start of out-of-sample test period 
testStart = datetime('2012-01-01');
testEnd   = testStart + calyears(1) - days(1);

% Number of investment periods (each investment period is 1 year long)
NoPeriods = 5;

% Factor models
% Note: You must populate the functios OLS.m, FF.m, LASSO.m and BSS.m with your
% own code.
FMList = {'OLS' 'FF' 'LASSO' 'BSS'};
FMList = cellfun(@str2func, FMList, 'UniformOutput', false);
NoModels = length(FMList);

% Tags for the portfolios under the different factor models
tags = {'OLS portfolio' 'FF portfolio' 'LASSO portfolio' 'BSS portfolio'};

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3. Construct and rebalance your portfolios
%
% Here you will estimate your input parameters (exp. returns and cov. 
% matrix etc) from the Fama-French factor models. You will have to 
% re-estimate your parameters at the start of each rebalance period, and 
% then re-optimize and rebalance your portfolios accordingly. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Initiate counter for the number of observations per investment period
toDay = 0;



% Preallocate the space for the per period value of the portfolios 
currentVal = zeros(NoPeriods, NoModels);

% -------------------------------------------------------------------------
% Prepare storage for RESULTS
% -------------------------------------------------------------------------
adjR2   = zeros(NoPeriods, NoModels);   % in‑sample fit
weights = cell(NoModels,1);            % store weights per model per period


%--------------------------------------------------------------------------
% Set the value of lambda and K for the LASSO and BSS models, respectively
%--------------------------------------------------------------------------
lambda = 0.8;
K      = 4;
fromDay = 1;

% Candidate values for lambda (LASSO) and K (BSS)
lambdaGrid = logspace(-4,1,40);
kGrid = 1:3;

% Store R² values for tuning visualization
R2_lasso_grid = NaN(length(lambdaGrid), NoPeriods);
R2_bss_grid   = NaN(length(kGrid), NoPeriods);

% store chosen lambda/K for each period
lambda_opt = NaN(NoPeriods, 1);
k_opt = NaN(NoPeriods, 1);



for t = 1 : NoPeriods
    
    % -------- data windows unchanged -------------------------------------
    periodReturns = table2array( returns( calStart <= dates & dates <= calEnd, :) );
    periodFactRet = table2array( factorRet( calStart <= dates & dates <= calEnd, :) );
    currentPrices = table2array( adjClose( ( calEnd - days(7) ) <= dates ...
                                                    & dates <= calEnd, :) )';
    periodPrices  = table2array( adjClose( testStart <= dates & dates <= testEnd,:) );

    fromDay = toDay + 1;
    toDay   = toDay + size(periodPrices,1);
    
    % -------- initialise portfolio value ---------------------------------
    if t == 1
        currentVal(t,:) = initialVal;
    else
        for i = 1 : NoModels
            currentVal(t,i) = currentPrices' * NoShares{i};
        end
    end
    
    % -------- in‑sample fit & μ,Q ----------------------------------------
    for i = 1 : NoModels
        
        modelName = func2str(FMList{i});
        switch modelName
            case 'LASSO'
            bestR2 = -Inf;
            lambdaGrid = logspace(-2, 2, 30);  % λ from 0.01 to 100

            % Split 4-year calibration period into 4 folds (1-year each)
            m = size(periodReturns,1);
            foldSize = floor(m / 4);
            folds = cell(1,4);
            for k = 1:4
                folds{k} = ((k-1)*foldSize+1):(k*foldSize);
            end

            for l = 1:length(lambdaGrid)
                lam = lambdaGrid(l);
                R2_folds = zeros(1,4);

                for f = 1:4
                    % Indices for train/test split
                    testIdx = folds{f};
                    trainIdx = setdiff(1:m, testIdx);

                    X_train = [ones(length(trainIdx),1), periodFactRet(trainIdx,:)];
                    X_test  = [ones(length(testIdx),1),  periodFactRet(testIdx,:)];

                    R2_assets = zeros(1, size(periodReturns,2));

                    for j = 1:size(periodReturns,2)
                        y_train = periodReturns(trainIdx, j);
                        y_test  = periodReturns(testIdx, j);

                        % Set up LASSO QP
                        d       = size(X_train,2);
                        A_split = [eye(d), -eye(d)];
                        A_train = X_train * A_split;

                        H = (2/length(y_train)) * (A_train' * A_train);
                        f_qp = lam * ones(2*d,1) - (2/length(y_train)) * (A_train' * y_train);
                        z = quadprog(H,f_qp,[],[],[],[],zeros(2*d,1),[],[],...
                                     optimoptions('quadprog','Display','off'));
                        beta = z(1:d) - z(d+1:end);

                        % Evaluate R² out-of-sample
                        y_pred = X_test * beta;
                        resid = y_test - y_pred;
                        R2_assets(j) = 1 - sum(resid.^2) / sum((y_test - mean(y_test)).^2);
                    end

                    R2_folds(f) = mean(R2_assets);
                end

                % Store for heatmap
                R2_lasso_grid(l,t) = mean(R2_folds);

                % If this λ is best so far, store the final model on full data
                if R2_lasso_grid(l,t) > bestR2
                    bestR2 = R2_lasso_grid(l,t);
                    [mu{i}, Q{i}] = LASSO(periodReturns, periodFactRet, lam, K);
                    lambda_opt(t) = lam;
                end
            end

            case 'BSS'
                bestR2 = -Inf;
                for kval = kGrid
                    [muTmp, QTmp] = BSS(periodReturns, periodFactRet, lambda, kval);
                    X = [ones(size(periodFactRet,1), 1), periodFactRet(:, 1:kval)];
                    Rs = getMeanAdjR2(X, periodReturns);
                    if Rs > bestR2
                        bestR2 = Rs;
                        mu{i} = muTmp;
                        Q{i} = QTmp;
                        k_opt(t) = kval;
                    end
                end
        
            otherwise
                [mu{i}, Q{i}] = FMList{i}(periodReturns, periodFactRet, lambda, K);
        end    
        % ► NEW: adjusted R² ------------------------------------------------
        switch func2str(FMList{i})
            case 'OLS'
                X = [ones(size(periodFactRet,1),1), periodFactRet]; % 1+8
                k_pred = 9;
            case 'FF'
                X = [ones(size(periodFactRet,1),1), periodFactRet(:,1:3)];%1+3
                k_pred = 4;
            case 'LASSO'
                X = [ones(size(periodFactRet,1),1), periodFactRet]; % same 1+8
                k_pred = 9;    % λ penalises complexity already – keep constant
            case 'BSS'
                X = [ones(size(periodFactRet,1),1), periodFactRet(:,1:K)];
                k_pred = K + 1;
        end
        
        % one R² per asset → store mean across assets
        Rs = zeros(size(periodReturns,2),1);
        for a = 1:size(periodReturns,2)
            y     = periodReturns(:,a);
            beta  = X\y;
            y_hat = X*beta;
            Rs(a) = calc_adjR2(y, y_hat, k_pred);
        end
        adjR2(t,i) = mean(Rs);
    end
            
    % -------- MVO optimisation -------------------------------------------
    for i = 1 : NoModels
        targetRet    = geomean(periodFactRet(:,1) + 1) - 1;
        x{i}(:,t)    = MVO(mu{i}, Q{i}, targetRet);
        weights{i}   = x{i};                     % ► keep weights
    end
    
    % -------- shares held & out‑of‑sample wealth --------------------------
    for i = 1 : NoModels
        NoShares{i} = x{i}(:,t) .* currentVal(t,i) ./ currentPrices;
        % Calculate individual asset returns over test period
        assetRets = (periodPrices(2:end,:) - periodPrices(1:end-1,:)) ./ periodPrices(1:end-1,:);
        assetRets = [zeros(1, size(assetRets,2)); assetRets];  % pad first row with zeros
        
        % Compute portfolio return over time
        portfRets = assetRets * NoShares{i} ./ sum(NoShares{i});  % weights fixed for period
        
        % Reconstruct portfolio value path
        portfValue(fromDay, i) = currentVal(t,i);  % starting value
        for k = 2:length(portfRets)
            portfValue(fromDay + k - 1, i) = portfValue(fromDay + k - 2, i) * (1 + portfRets(k));
        end
    end
    
    % -------- roll windows forward ---------------------------------------

    
    calStart = calStart + calyears(1);
    calEnd   = calStart + calyears(4) - days(1);
    testStart = testStart + calyears(1);
    testEnd   = testStart + calyears(1) - days(1);

    if ~isnan(lambda_opt(t))
    fprintf('→ Period %d: Optimal lambda = %.3f\n', t, lambda_opt(t));
    end
    if ~isnan(k_opt(t))
        fprintf('→ Period %d: Optimal K = %d\n', t, k_opt(t));
    end
end   % ← end main period loop


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4. Results
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------------------------------------------------------------
% 4.1 Evaluate any measures of fit of the regression models to assess their
% in-sample quality. You may want to modify Section 3 of this program to
% calculate the quality of fit each time the models are recalibrated.
%--------------------------------------------------------------------------

meanAdjR2 = mean(adjR2,1);                    % average across periods

fprintf('\n*** In‑sample adjusted R² (mean across 5 calibrations) ***\n');
for i = 1:NoModels
    fprintf('%-15s  %.4f\n', tags{i}, meanAdjR2(i));
end

%--------------------------------------------------------------------------
% 4.2 Calculate the portfolio average return, variance (or standard 
% deviation), and any other performance and/or risk metric you wish to 
% include in your report.
%--------------------------------------------------------------------------

portfRet = diff(portfValue) ./ portfValue(1:end-1,:);     % ΔW / W_{t-1}

avgRet   = mean(portfRet);                % weekly mean
vol      = std (portfRet);                % weekly st.dev.
sharpe   = avgRet ./ vol;                 % weekly Sharpe

annFactor = sqrt(12);                     % annualise vol & Sharpe
annRet    = (1+avgRet).^12 - 1;           % geometric approx
annVol    = vol * annFactor;
annSharpe = sharpe * annFactor;

fprintf('\n*** Out‑of‑sample performance (annualised) 2012‑2016 ***\n');
fprintf('%-10s  %8s  %8s  %8s\n','Model','Return','St.dev','Sharpe');
for i = 1:NoModels
    fprintf('%-10s  %8.2f  %8.2f  %8.2f\n', ...
        tags{i}, 100*annRet(i), 100*annVol(i), annSharpe(i) );
end


%--------------------------------------------------------------------------
% 4.3 Plot the portfolio wealth evolution 
% 
% Note: The code below plots all portfolios onto a single plot. However,
% you may want to split this into multiple plots for clarity, or to
% compare a subset of the portfolios. 
%--------------------------------------------------------------------------
plotDates = dates(dates >= datetime('2012-01-01') );

fig1 = figure(1);

for i = 1 : NoModels
    
    plot( plotDates, portfValue(:,i) )
    hold on
    
end

legend(tags, 'Location', 'eastoutside','FontSize',12);
datetick('x','dd-mmm-yyyy','keepticks','keeplimits');
set(gca,'XTickLabelRotation',30);
title('Portfolio value', 'FontSize', 14)
ylabel('Value','interpreter','latex','FontSize',12);

% Define the plot size in inches
set(fig1,'Units','Inches', 'Position', [0 0 8, 5]);
pos1 = get(fig1,'Position');
set(fig1,'PaperPositionMode','Auto','PaperUnits','Inches',...
    'PaperSize',[pos1(3), pos1(4)]);

% If you want to save the figure as .pdf for use in LaTeX
% print(fig1,'fileName','-dpdf','-r0');

% If you want to save the figure as .png for use in MS Word
print(fig1,'fileName','-dpng','-r0');

%--------------------------------------------------------------------------
% 4.4 Plot the portfolio weights period-over-period
%--------------------------------------------------------------------------

% OLS portfolio weights
fig2 = figure(2);
area(x{1}')
legend(tickers, 'Location', 'eastoutside','FontSize',12);
title('OLS portfolio weights', 'FontSize', 14)
ylabel('Weights','interpreter','latex','FontSize',12);
xlabel('Rebalance period','interpreter','latex','FontSize',12);

% Define the plot size in inches
set(fig2,'Units','Inches', 'Position', [0 0 8, 5]);
pos1 = get(fig2,'Position');
set(fig2,'PaperPositionMode','Auto','PaperUnits','Inches',...
    'PaperSize',[pos1(3), pos1(4)]);

% If you want to save the figure as .pdf for use in LaTeX
% print(fig2,'fileName2','-dpdf','-r0');

% If you want to save the figure as .png for use in MS Word
print(fig2,'fileName2','-dpng','-r0');

for i = 1:NoModels
    figure(1+i)               % figs 2..5
    area(x{i}')
    legend(tickers, 'Location','eastoutside','FontSize',10);
    title([tags{i} ' weights'],'FontSize',14)
    ylabel('Weights'), xlabel('Rebalance period')
end

% Helper Function
function R2_mean = getMeanAdjR2(X, Y)
    % X: T x k design matrix (intercept + factors)
    % Y: T x n matrix of actual asset returns
    % R2_mean: scalar average adjusted R² across assets

    [T, n] = size(Y);
    k_pred = size(X, 2);
    Rs = zeros(n, 1);

    for i = 1:n
        y     = Y(:, i);
        beta  = X \ y;
        yhat  = X * beta;
        SSE   = sum((y - yhat).^2);
        SST   = sum((y - mean(y)).^2);
        R2    = 1 - SSE / SST;
        Rs(i) = 1 - (1 - R2) * (T - 1) / (T - k_pred);
    end

    R2_mean = mean(Rs);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Program End
mean_R2 = mean(R2_lasso_grid(:, 1:t), 2);
semilogx(lambdaGrid, mean_R2);